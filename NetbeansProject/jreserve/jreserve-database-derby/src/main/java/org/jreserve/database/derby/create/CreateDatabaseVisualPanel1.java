package org.jreserve.database.derby.create;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.jreserve.database.AbstractDatabase;
import org.jreserve.database.DatabaseUtil;
import org.jreserve.database.derby.DerbyDatabase;
import org.jreserve.resources.FileChooser;
import org.jreserve.resources.images.ImageResources;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;

@NbBundle.Messages({
    "CTL_StepOne=Select location",
    "CTL_location=Location:",
    "CTL_name=Name:",
    "CTL_path=Path:",
    "CTL_Browse=Browse...",
    "CTL_FileChooserTitle=Choose parent directory",
    "ERR_NameEmpty=Field 'Name' is empty!",
    "ERR_LocationEmpty=Field 'Location' is empty!",
    "#0 - Location path",
    "ERR_LocationNotFound=Directory '{0}' does not exists!",
    "ERR_PathNotDatabase=File \"{0}\" is not a derby database!",
    "ERR_dbNameAlreadyExists=Database with name \"{0}\" is already exists!",
    "ERR_dbNameAlreadyExistsNotOpened=Database with name \"{0}\" is already exists, but it is not opened!"
})
final class CreateDatabaseVisualPanel1 extends JPanel implements DocumentListener {
    
    private final static String SEPARATOR = System.getProperty("file.separator");
    private CreateDatabaseWizardPanel1 descriptor;
    private String path;
    
    private ActionListener browseListener = new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            String path = browseParentDirectory();
            if(path != null)
                locationText.setText(path);
        }
    };
    
    public CreateDatabaseVisualPanel1(CreateDatabaseWizardPanel1 descriptor) {
        this.descriptor = descriptor;
        initComponents();
    }

    @Override
    public String getName() {
        return Bundle.CTL_StepOne();
    }
    
    private String browseParentDirectory() {
        File basePath = new File (System.getProperty("netbeans.user"));
        File db = new FileChooser(CreateDatabaseVisualPanel1.class)
            .setTitle(Bundle.CTL_FileChooserTitle())
            .setDefaultWorkingDirectory(basePath)
            .setDirectoriesOnly(true)
            .showOpenDialog();
        return db==null? null : db.getAbsolutePath();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        nameLabel = new javax.swing.JLabel();
        locationLabel = new javax.swing.JLabel();
        nameText = new javax.swing.JTextField();
        locationText = new javax.swing.JTextField();
        browseButton = new javax.swing.JButton();
        errorLabel = new javax.swing.JLabel();
        pathLabel = new javax.swing.JLabel();
        pathText = new javax.swing.JTextField();

        org.openide.awt.Mnemonics.setLocalizedText(nameLabel, Bundle.CTL_name());

        org.openide.awt.Mnemonics.setLocalizedText(locationLabel, Bundle.CTL_location());

        nameText.setText(org.openide.util.NbBundle.getMessage(CreateDatabaseVisualPanel1.class, "CreateDatabaseVisualPanel1.nameText.text")); // NOI18N
        nameText.getDocument().addDocumentListener(this);

        locationText.setText(org.openide.util.NbBundle.getMessage(CreateDatabaseVisualPanel1.class, "CreateDatabaseVisualPanel1.locationText.text")); // NOI18N
        locationText.getDocument().addDocumentListener(this);

        org.openide.awt.Mnemonics.setLocalizedText(browseButton, Bundle.CTL_Browse());
        browseButton.addActionListener(browseListener);

        errorLabel.setIcon(ImageResources.error());
        errorLabel.setText(org.openide.util.NbBundle.getMessage(CreateDatabaseVisualPanel1.class, "CreateDatabaseVisualPanel1.errorLabel.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(pathLabel, Bundle.CTL_path());

        pathText.setEditable(false);
        pathText.setText(org.openide.util.NbBundle.getMessage(CreateDatabaseVisualPanel1.class, "CreateDatabaseVisualPanel1.pathText.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(errorLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(pathLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(locationLabel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(nameLabel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(locationText, javax.swing.GroupLayout.DEFAULT_SIZE, 563, Short.MAX_VALUE)
                                    .addComponent(nameText))
                                .addGap(18, 18, 18)
                                .addComponent(browseButton))
                            .addComponent(pathText))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nameLabel)
                    .addComponent(nameText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(locationLabel)
                    .addComponent(locationText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(browseButton))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pathLabel)
                    .addComponent(pathText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 221, Short.MAX_VALUE)
                .addComponent(errorLabel)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton browseButton;
    private javax.swing.JLabel errorLabel;
    private javax.swing.JLabel locationLabel;
    private javax.swing.JTextField locationText;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JTextField nameText;
    private javax.swing.JLabel pathLabel;
    private javax.swing.JTextField pathText;
    // End of variables declaration//GEN-END:variables

    @Override
    public void insertUpdate(DocumentEvent e) {
        updatePath();
    }

    @Override
    public void removeUpdate(DocumentEvent e) {
        updatePath();
    }

    @Override
    public void changedUpdate(DocumentEvent e) {
        updatePath();
    }
    
    private void updatePath() {
        path = getPath();
        pathText.setText(path);
        checkFields();
        descriptor.fireChange();
    }
    
    String getPath() {
        String dir = getLocationText();
        if(!dir.endsWith("/") && !dir.endsWith("\\"))
            dir += SEPARATOR;
        return dir + getNameText();
    }
    
    String getLocationText() {
        return escapeTextFromField(locationText);
    }
    
    void setLocation(String location) {
        locationText.setText(location);
    }
    
    private String escapeTextFromField(JTextField textField) {
        String str = textField.getText();
        if(str == null)
            return "";
        return str.trim();
    }
    
    String getNameText() {
        return escapeTextFromField(nameText);
    }
    
    void setDbName(String name) {
        nameText.setText(name);
    }
    
    private void checkFields() {
        errorLabel.setText("");
        boolean isValid = checkName() && checkLocation() && checkPath();
        errorLabel.setVisible(!isValid);
        descriptor.setValid(isValid);
    }
    
    private boolean checkName() {
        if(getNameText().length() != 0)
            return true;
        errorLabel.setText(Bundle.ERR_NameEmpty());
        return false;
    }
    
    private boolean checkLocation() {
        if(getLocationText().length() != 0)
            return checkLocationExists();
        errorLabel.setText(Bundle.ERR_LocationEmpty());
        return false;
    }
    
    private boolean checkLocationExists() {
        File location = new File(getLocationText());
        if(location.isDirectory())
            return true;
        errorLabel.setText(Bundle.ERR_LocationNotFound(location));
        return false;
    }
    
    private boolean checkPath() {
        return checkFile() &&
               checkNameNotExists();
    }
    
    private boolean checkFile() {
        File file = new File(path);
        if(file.exists())
            return isDerbyDirectory(file);
        return true;
    }
    
    private boolean isDerbyDirectory(File file) {
        if(new DerbyDirectoryValidator(file).isDerbyDatabase())
            return true;
        errorLabel.setText(Bundle.ERR_PathNotDatabase(file));
        return false;
    }
    
    private boolean checkNameNotExists() {
        AbstractDatabase db = DatabaseUtil.getDatabaseByName(getNameText());
        if(db == null)
            return true;
        setNameExistsText(db);
        return false;
    }
    
    private void setNameExistsText(AbstractDatabase db) {
        if(db.isOpened()) {
            errorLabel.setText(Bundle.ERR_dbNameAlreadyExists(db.getShortName()));
        } else {
            errorLabel.setText(Bundle.ERR_dbNameAlreadyExistsNotOpened(db.getShortName()));
        }
    }
    
    private List<AbstractDatabase> getDatabases() {
        return new ArrayList<AbstractDatabase>(
            Lookup.getDefault().lookupAll(AbstractDatabase.class));
    }
    
    private boolean sameDatabase(AbstractDatabase database) {
        if(!(database instanceof DerbyDatabase))
            return false;
        File dbHome = new File(((DerbyDatabase) database).getDatabaseFolder());
        return dbHome.equals(new File(path));
    }
}

